import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn.ensemble import RandomForestRegressor
from sklearn.neural_network import MLPRegressor
from scipy.optimize import minimize
import time
import json
import os

class UniversalNPSolver:
    def __init__(self):
        # База знаний для самообучения
        self.knowledge_base = "knowledge_db.json"
        self.load_knowledge()
        
        # Параметры спирали
        self.spiral_params = {
            'base_radius': 100,     # Базовый радиус спирали
            'height_factor': 0.5,   # Фактор высоты
            'twist_factor': 0.2,    # Фактор закручивания
            'tilt_angle': 31,       # Угол наклона (31 градус)
            'rotation': 180         # Разворот (180 градусов)
        }
        
        # ML модели для оптимизации
        self.topology_optimizer = MLPRegressor(hidden_layer_sizes=(100, 50))
        self.platform_selector = RandomForestRegressor()
        self.error_corrector = MLPRegressor(hidden_layer_sizes=(50, 25))
        
        # Инициализация моделей
        self.initialize_models()

    def load_knowledge(self):
        """Загрузка базы знаний из файла"""
        if os.path.exists(self.knowledge_base):
            with open(self.knowledge_base, 'r') as f:
                self.knowledge = json.load(f)
        else:
            self.knowledge = {
                'problems': {},
                'solutions': {},
                'performance_stats': {}
            }
    
    def save_knowledge(self):
        """Сохранение базы знаний в файл"""
        with open(self.knowledge_base, 'w') as f:
            json.dump(self.knowledge, f, indent=2)
    
    def initialize_models(self):
        """Инициализация ML моделей на основе имеющихся знаний"""
        # Здесь должна быть логика загрузки предобученных моделей
        # В демо-версии просто инициализируем "пустые" модели
        pass
    
    def geometric_encoder(self, problem):
        """Преобразование задачи в геометрическую модель"""
        problem_type = problem['type']
        size = problem['size']
        
        # Генерация параметрической спирали
        t = np.linspace(0, 20 * np.pi, 1000)
        r = self.spiral_params['base_radius'] * (1 - t/(20*np.pi))
        
        # Преобразование с учетом угла наклона и разворота
        tilt = np.radians(self.spiral_params['tilt_angle'])
        rotation = np.radians(self.spiral_params['rotation'])
        
        x = r * np.sin(t + rotation)
        y = r * np.cos(t + rotation) * np.cos(tilt) - t * self.spiral_params['height_factor'] * np.sin(tilt)
        z = r * np.cos(t + rotation) * np.sin(tilt) + t * self.spiral_params['height_factor'] * np.cos(tilt)
        
        return {'x': x, 'y': y, 'z': z, 't': t, 'problem_type': problem_type, 'size': size}
    
    def physical_solver(self, topology, method='hybrid'):
        """Решение задачи на геометрической модели"""
        # P-точки (базовые параметры)
        p_points = self.identify_p_points(topology)
        
        # NP-точки (сложные параметры)
        np_points = self.identify_np_points(topology, p_points)
        
        # Оптимизационное решение
        if method == 'gradient':
            solution = self.gradient_optimization(topology, np_points)
        elif method == 'evolutionary':
            solution = self.evolutionary_optimization(topology, np_points)
        else:  # hybrid
            solution = self.hybrid_optimization(topology, np_points)
        
        # Сохранение решения в базе знаний
        problem_id = f"{topology['problem_type']}_{topology['size']}"
        self.knowledge['solutions'][problem_id] = {
            'solution': solution,
            'timestamp': time.time(),
            'method': method
        }
        
        return solution
    
    def identify_p_points(self, topology):
        """Идентификация P-точек (базовые параметры)"""
        # В реальной реализации здесь сложная логика идентификации
        # Для демо - фиксированные точки
        return [
            {'index': 100, 'type': 'base', 'value': topology['x'][100]},
            {'index': 400, 'type': 'height', 'value': topology['z'][400]},
            {'index': 700, 'type': 'angle', 'value': topology['t'][700]}
        ]
    
    def identify_np_points(self, topology, p_points):
        """Идентификация NP-точек (сложные параметры)"""
        # Здесь должна быть сложная аналитическая логика
        # Для демо - точки, связанные с числами из пирамиды
        return [
            {'index': 185, 'type': 'key', 'value': 185},
            {'index': 236, 'type': 'rhythm', 'value': 236},
            {'index': 38, 'type': 'tunnel', 'value': 38},
            {'index': 451, 'type': 'fire', 'value': 451}
        ]
    
    def hybrid_optimization(self, topology, np_points):
        """Гибридный метод оптимизации"""
        # Градиентная оптимизация
        initial_guess = [point['value'] for point in np_points]
        bounds = [(val*0.5, val*1.5) for point in np_points for val in [point['value']]]
        
        result = minimize(
            self.optimization_target,
            initial_guess,
            args=(topology, np_points),
            method='L-BFGS-B',
            bounds=bounds,
            options={'maxiter': 1000}
        )
        
        # Эволюционная оптимизация для уточнения
        if not result.success:
            return self.evolutionary_optimization(topology, np_points)
        
        return result.x
    
    def optimization_target(self, params, topology, np_points):
        """Целевая функция для оптимизации"""
        # Рассчитываем отклонение от целевых точек
        error = 0
        for i, point in enumerate(np_points):
            idx = point['index']
            target = point['value']
            calculated = self.calculate_point_value(params[i], topology, idx)
            error += (target - calculated)**2
        
        return error
    
    def calculate_point_value(self, param, topology, index):
        """Расчет значения точки на спирали"""
        # В реальной реализации сложная функция
        # Для демо - линейная интерполяция
        return topology['x'][index] * param
    
    def evolutionary_optimization(self, topology, np_points):
        """Эволюционная оптимизация"""
        # Упрощенная реализация
        best_solution = None
        best_error = float('inf')
        
        for _ in range(1000):
            candidate = [point['value'] * np.random.uniform(0.8, 1.2) for point in np_points]
            error = self.optimization_target(candidate, topology, np_points)
            
            if error < best_error:
                best_error = error
                best_solution = candidate
        
        return best_solution
    
    def verify_solution(self, solution, topology):
        """Верификация решения"""
        # Проверка соответствия ожидаемым параметрам
        verification_passed = True
        verification_report = {}
        
        for i, point in enumerate(self.identify_np_points(topology, [])):
            expected = point['value']
            actual = solution[i]
            tolerance = expected * 0.05  # 5% допуск
            
            verification_report[point['type']] = {
                'expected': expected,
                'actual': actual,
                'deviation': abs(expected - actual),
                'tolerance': tolerance,
                'passed': abs(expected - actual) <= tolerance
            }
            
            if not verification_report[point['type']]['passed']:
                verification_passed = False
        
        # Автокоррекция при необходимости
        if not verification_passed:
            corrected_solution = self.auto_correct(solution, verification_report)
            return self.verify_solution(corrected_solution, topology)
        
        return verification_passed, verification_report
    
    def auto_correct(self, solution, verification_report):
        """Автоматическая коррекция решения"""
        corrected = solution.copy()
        for i, (key, report) in enumerate(verification_report.items()):
            if not report['passed']:
                # Простая коррекция: движение к ожидаемому значению
                correction_factor = 0.5 if report['deviation'] > report['expected'] * 0.1 else 0.2
                corrected[i] = (1 - correction_factor) * corrected[i] + correction_factor * report['expected']
        
        return corrected
    
    def visualize_solution(self, topology, solution, np_points):
        """3D визуализация решения"""
        fig = plt.figure(figsize=(14, 10))
        ax = fig.add_subplot(111, projection='3d')
        
        # Отображение спирали
        ax.plot(topology['x'], topology['y'], topology['z'], 'b-', alpha=0.6, label='Спираль решения')
        
        # P-точки
        p_points = self.identify_p_points(topology)
        p_x = [topology['x'][p['index']] for p in p_points]
        p_y = [topology['y'][p['index']] for p in p_points]
        p_z = [topology['z'][p['index']] for p in p_points]
        ax.scatter(p_x, p_y, p_z, c='green', s=100, marker='o', label='P-точки')
        
        # NP-точки
        np_x = [topology['x'][p['index']] for p in np_points]
        np_y = [topology['y'][p['index']] for p in np_points]
        np_z = [topology['z'][p['index']] for p in np_points]
        ax.scatter(np_x, np_y, np_z, c='red', s=150, marker='^', label='NP-точки')
        
        # Решение
        sol_x = [topology['x'][i] for i in [185, 236, 38, 451]]
        sol_y = [topology['y'][i] for i in [185, 236, 38, 451]]
        sol_z = [solution[i] for i in range(len(solution))]  # Z-координата из решения
        ax.scatter(sol_x, sol_y, sol_z, c='gold', s=200, marker='*', label='Решение')
        
        # Соединение точек решения
        for i in range(len(sol_x) - 1):
            ax.plot([sol_x[i], sol_x[i+1]], [sol_y[i], sol_y[i+1]], [sol_z[i], sol_z[i+1]], 
                    'm--', linewidth=2)
        
        # Настройки визуализации
        ax.set_title(f"Решение NP-задачи: {topology['problem_type']} (Размер: {topology['size']})", fontsize=14)
        ax.set_xlabel('Ось X')
        ax.set_ylabel('Ось Y')
        ax.set_zlabel('Ось Z')
        ax.legend()
        
        # Сохранение и отображение
        plt.savefig(f"solution_{topology['problem_type']}_{topology['size']}.png")
        plt.show()
    
    def self_improve(self):
        """Процесс самообучения системы"""
        # Анализ последних решений
        recent_solutions = sorted(
            self.knowledge['solutions'].items(),
            key=lambda x: x[1]['timestamp'],
            reverse=True
        )[:10]  # Последние 10 решений
        
        # Оптимизация параметров спирали
        self.optimize_spiral_params(recent_solutions)
        
        # Переобучение ML моделей
        self.retrain_models(recent_solutions)
        
        # Сохранение обновленных знаний
        self.save_knowledge()
    
    def optimize_spiral_params(self, solutions):
        """Оптимизация параметров спирали на основе последних решений"""
        # Упрощенная реализация - случайный поиск
        for param in self.spiral_params:
            current_value = self.spiral_params[param]
            new_value = current_value * np.random.uniform(0.95, 1.05)
            self.spiral_params[param] = new_value
    
    def retrain_models(self, solutions):
        """Переобучение ML моделей на новых данных"""
        # В реальной системе здесь было бы извлечение признаков и обучение
        # Для демо - просто логируем
        print(f"Переобучение моделей на {len(solutions)} примерах...")
    
    def full_cycle(self, problem):
        """Полный цикл решения задачи"""
        print(f"\n{'='*40}")
        print(f"Начало решения задачи: {problem['type']} (Размер: {problem['size']})")
        print(f"{'='*40}")
        
        # Шаг 1: Геометрическое кодирование
        start_time = time.time()
        topology = self.geometric_encoder(problem)
        encode_time = time.time() - start_time
        print(f"Геометрическое кодирование завершено за {encode_time:.4f} сек")
        
        # Шаг 2: Физическое решение
        start_time = time.time()
        solution = self.physical_solver(topology)
        solve_time = time.time() - start_time
        print(f"Физическое решение найдено за {solve_time:.4f} сек")
        
        # Шаг 3: Верификация
        start_time = time.time()
        verification_passed, report = self.verify_solution(solution, topology)
        verify_time = time.time() - start_time
        
        if verification_passed:
            print(f"Верификация пройдена успешно за {verify_time:.4f} сек")
        else:
            print(f"Верификация выявила ошибки за {verify_time:.4f} сек")
            for point, data in report.items():
                status = "ПРОЙДЕНА" if data['passed'] else "ОШИБКА"
                print(f" - {point}: {status} (Ожидалось: {data['expected']:.2f}, Получено: {data['actual']:.2f})")
        
        # Шаг 4: Визуализация
        np_points = self.identify_np_points(topology, [])
        self.visualize_solution(topology, solution, np_points)
        
        # Шаг 5: Самообучение
        self.self_improve()
        
        return solution, verification_passed

# =============================================================================
# Пример использования
# =============================================================================

if __name__ == "__main__":
    # Инициализация решателя
    solver = UniversalNPSolver()
    
    # Определение задач для решения
    problems = [
        {'type': 'SAT', 'size': 100},
        {'type': 'TSP', 'size': 50},
        {'type': 'Crypto', 'size': 256}
    ]
    
    # Решение каждой задачи
    for problem in problems:
        solution, passed = solver.full_cycle(problem)
        
        # Дополнительная аналитика
        if passed:
            print("Решение верифицировано успешно!")
            print("Оптимальные параметры:", solution)
        else:
            print("Решение требует дополнительной оптимизации")
        
        print("\n" + "="*60 + "\n")
    
    # Финальное сохранение знаний
    solver.save_knowledge()
    print("База знаний успешно сохранена")